// ==============================
// index.js Ôºà"type": "module" ÂâçÊèêÔºâ
// ==============================

import {
  Client, GatewayIntentBits, Partials,
  ActionRowBuilder, ButtonBuilder, ButtonStyle,
  StringSelectMenuBuilder,
  ModalBuilder, TextInputBuilder, TextInputStyle,
  EmbedBuilder, InteractionType, PermissionsBitField,
  Events, Colors
} from "discord.js";
import { Pool } from "pg";
import dotenv from "dotenv";
import schedule from "node-schedule";
import crypto from "crypto";
import http from "http";

dotenv.config();
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

// ==============================
// „ÇØ„É©„Ç§„Ç¢„É≥„Éà
// ==============================
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
});

// ==============================
// Áí∞Â¢ÉË®≠ÂÆö
// ==============================
const DAILY_AMOUNT        = parseInt(process.env.DAILY_AMOUNT || "100", 10);
const REWARD_ROLE_ID      = process.env.REWARD_ROLE_ID || "";
const REWARD_PER_MESSAGE  = parseInt(process.env.REWARD_PER_MESSAGE || "10", 10);
const REWARD_DAILY_LIMIT  = parseInt(process.env.REWARD_DAILY_LIMIT || "10", 10);
const REWARD_COOLDOWN_SEC = parseInt(process.env.REWARD_COOLDOWN_SEC || "45", 10);
const CASINO_CHANNEL_ID   = process.env.CASINO_CHANNEL_ID || "";

// ==============================
// „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
// ==============================
function createEmbed(title, desc, color = Colors.Blurple) {
  return new EmbedBuilder().setTitle(title).setDescription(desc).setColor(color);
}
const fmt = (n) => Number(n).toLocaleString("ja-JP");

function limitContent(s, limit = 1900) {
  if (!s) return s;
  if (s.length <= limit) return s;
  return s.slice(0, limit - 20) + "\n‚Ä¶ÔºàÁúÅÁï•Ôºâ";
}
function formatJST(ts) {
  const d = new Date(ts);
  const parts = new Intl.DateTimeFormat("ja-JP", {
    timeZone: "Asia/Tokyo",
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit",
  }).formatToParts(d);
  const get = (t) => parts.find((p) => p.type === t)?.value ?? "";
  return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
}
const todayJST = () =>
  new Intl.DateTimeFormat("en-CA", { timeZone: "Asia/Tokyo", year: "numeric", month: "2-digit", day: "2-digit" })
    .format(new Date()); // YYYY-MM-DD

async function ephemeralReply(interaction, payload, ms = 15000) {
  const data = { ...payload };
  if (typeof data.content === "string") data.content = limitContent(data.content);
  const msg = await interaction.reply({ ...data, ephemeral: true });
  setTimeout(() => interaction.deleteReply().catch(() => {}), ms);
  return msg;
}
async function ephemeralUpdate(interaction, payload, ms = 15000) {
  const data = { ...payload };
  if (typeof data.content === "string") data.content = limitContent(data.content);
  const msg = await interaction.update({ ...data });
  setTimeout(() => interaction.deleteReply().catch(() => {}), ms);
  return msg;
}

// „Ç≥„Ç§„É≥Âä†ÁÆóÔºàÂ∑ÆÈ°çË®òÈå≤ÔºãÂ±•Ê≠¥Ôºâ
async function addCoins(userId, amount, type, note = null) {
  const n = Math.trunc(Number(amount) || 0);
  await pool.query(
    `INSERT INTO coins (user_id, balance)
     VALUES ($1,$2)
     ON CONFLICT (user_id) DO UPDATE SET balance = coins.balance + EXCLUDED.balance`,
    [userId, n]
  );
  await pool.query(
    `INSERT INTO history (user_id, type, amount, note, created_at)
     VALUES ($1,$2,$3,$4,NOW())`,
    [userId, type, n, note]
  );
}
// ==============================
// DBÂàùÊúüÂåñ
// ==============================
async function ensureTables() {
  await pool.query(`CREATE TABLE IF NOT EXISTS coins (
    user_id TEXT PRIMARY KEY,
    balance INTEGER DEFAULT 0
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS history (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    type TEXT NOT NULL,
    amount INTEGER NOT NULL,
    note TEXT,
    created_at TIMESTAMP DEFAULT now()
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS daily_claims (
    user_id TEXT PRIMARY KEY,
    last_claim DATE
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS message_rewards (
    user_id TEXT PRIMARY KEY,
    date TEXT,
    count INTEGER DEFAULT 0,
    last_message_at TIMESTAMP,
    last_message_hash TEXT
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS rumuma_races (
    id SERIAL PRIMARY KEY,
    channel_id TEXT,
    host_id TEXT,
    race_name TEXT,
    horses TEXT[],
    finished BOOLEAN DEFAULT false,
    winner TEXT
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS rumuma_bets (
    id SERIAL PRIMARY KEY,
    race_id INTEGER NOT NULL REFERENCES rumuma_races(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL,
    horse TEXT NOT NULL,
    amount INTEGER NOT NULL
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS rumuma_results (
    id SERIAL PRIMARY KEY,
    race_id INTEGER,
    race_name TEXT,
    horses TEXT[],
    winner TEXT,
    total_pot INTEGER,
    status TEXT,
    finished_at TIMESTAMP DEFAULT now()
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS pending_rewards (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    race_id INTEGER NOT NULL,
    race_name TEXT NOT NULL,
    amount INTEGER NOT NULL,
    claimed BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT now()
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS slot_states (
    user_id TEXT PRIMARY KEY,
    mode TEXT NOT NULL DEFAULT 'NORMAL',
    spins_left INTEGER NOT NULL DEFAULT 0,
    updated_at TIMESTAMP DEFAULT now()
  );`);

  await pool.query(`CREATE TABLE IF NOT EXISTS slot_config (
    id SERIAL PRIMARY KEY,
    big NUMERIC DEFAULT 0.006,
    reg NUMERIC DEFAULT 0.012,
    grape NUMERIC DEFAULT 0.20,
    cherry NUMERIC DEFAULT 0.10,
    updated_at TIMESTAMP DEFAULT now()
  );`);
}

// ==============================
// „Ç≥„Ç§„É≥Á≥ªÔºöÊÆãÈ´òÁ¢∫Ë™ç
// ==============================
async function getBalance(userId) {
  const rs = await pool.query(`SELECT balance FROM coins WHERE user_id=$1`, [userId]);
  return rs.rowCount ? Number(rs.rows[0].balance) : 0;
}

// ==============================
// „Éá„Ç§„É™„ÉºÂ†±ÈÖ¨
// ==============================
async function claimDaily(interaction) {
  const uid = interaction.user.id;
  const today = todayJST();

  const rs = await pool.query(`SELECT last_claim FROM daily_claims WHERE user_id=$1`, [uid]);
  if (rs.rowCount && rs.rows[0].last_claim === today) {
    return ephemeralReply(interaction, { content: "üìÖ ‰ªäÊó•„ÅØ„Åô„Åß„Å´„Éá„Ç§„É™„ÉºÂ†±ÈÖ¨„ÇíÂèó„ÅëÂèñ„ÇäÊ∏à„Åø„Åß„Åô„ÄÇ" });
  }

  await pool.query(`
    INSERT INTO daily_claims(user_id,last_claim)
    VALUES($1,$2)
    ON CONFLICT (user_id) DO UPDATE SET last_claim=EXCLUDED.last_claim
  `, [uid, today]);

  await addCoins(uid, DAILY_AMOUNT, "daily", "„Éá„Ç§„É™„ÉºÂ†±ÈÖ¨");

  return ephemeralReply(interaction, { content: `‚úÖ „Éá„Ç§„É™„ÉºÂ†±ÈÖ¨ ${fmt(DAILY_AMOUNT)}S „ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åó„ÅüÔºÅ` });
}

// ==============================
// Áô∫Ë®ÄÂ†±ÈÖ¨
// ==============================
async function handleMessageReward(message) {
  if (message.author.bot) return;
  const uid = message.author.id;
  const today = todayJST();

  const hash = crypto.createHash("md5").update(message.content).digest("hex");
  const rs = await pool.query(`SELECT * FROM message_rewards WHERE user_id=$1`, [uid]);
  const now = new Date();

  if (rs.rowCount) {
    const row = rs.rows[0];
    if (row.date === today && row.count >= REWARD_DAILY_LIMIT) return;
    if (row.last_message_hash === hash) return;
    if (row.last_message_at && (now - new Date(row.last_message_at)) / 1000 < REWARD_COOLDOWN_SEC) return;

    await pool.query(`
      UPDATE message_rewards
      SET date=$2,count=CASE WHEN date=$2 THEN count+1 ELSE 1 END,
          last_message_at=now(), last_message_hash=$3
      WHERE user_id=$1
    `, [uid, today, hash]);
  } else {
    await pool.query(`
      INSERT INTO message_rewards(user_id,date,count,last_message_at,last_message_hash)
      VALUES($1,$2,1,now(),$3)
    `, [uid, today, hash]);
  }

  await addCoins(uid, REWARD_PER_MESSAGE, "message", "Áô∫Ë®ÄÂ†±ÈÖ¨");
}

// ==============================
// „É©„É≥„Ç≠„É≥„Ç∞Ë°®Á§∫
// ==============================
async function showRanking(interaction) {
  const rs = await pool.query(`SELECT user_id,balance FROM coins ORDER BY balance DESC LIMIT 10`);
  let desc = "";
  for (let i=0; i<rs.rowCount; i++) {
    const row = rs.rows[i];
    desc += `#${i+1} <@${row.user_id}> ‚Äî ${fmt(row.balance)}S\n`;
  }
  return ephemeralReply(interaction, { embeds: [createEmbed("üí∞ „Ç≥„Ç§„É≥„É©„É≥„Ç≠„É≥„Ç∞TOP10", desc)] });
}
// ==============================
// „É¨„Éº„ÇπËøîÈáëÔºà‰∏≠Ê≠¢Ôºâ
// ==============================
async function refundRumuma(raceId, reason="ÈñãÂÇ¨‰∏≠Ê≠¢") {
  const raceRes = await pool.query(`SELECT race_name,horses FROM rumuma_races WHERE id=$1`, [raceId]);
  const betsRes = await pool.query(`SELECT amount,user_id FROM rumuma_bets WHERE race_id=$1`, [raceId]);

  let total = 0;
  for (const b of betsRes.rows) total += Number(b.amount);

  for (const b of betsRes.rows) {
    await addCoins(b.user_id, b.amount, "rumuma_refund", `Race:${raceId} ${reason}`);
  }

  await pool.query(`
    INSERT INTO rumuma_results(race_id,race_name,horses,winner,total_pot,status,finished_at)
    VALUES($1,$2,$3,$4,$5,'canceled',now())
  `, [raceId, raceRes.rows[0]?.race_name, raceRes.rows[0]?.horses, null, total]);

  await pool.query(`DELETE FROM rumuma_bets WHERE race_id=$1`, [raceId]);
  await pool.query(`DELETE FROM rumuma_races WHERE id=$1`, [raceId]);
}

// ==============================
// „Ç™„ÉÉ„Ç∫Ë®àÁÆóÔºàÂÄçÁéá„ÅÆ„ÅøÔºâ
// ==============================
async function calcOdds(raceId) {
  const res = await pool.query(
    `SELECT horse,SUM(amount)::bigint AS sum FROM rumuma_bets WHERE race_id=$1 GROUP BY horse`,
    [raceId]
  );
  const totalPot = res.rows.reduce((s,b) => s + Number(b.sum), 0);
  const odds = {};
  for (const row of res.rows) {
    const h = row.horse;
    const betSum = Number(row.sum);
    odds[h] = betSum > 0 ? (totalPot / betSum).toFixed(2) : "‚Äî";
  }
  return { totalPot, odds };
}

// ==============================
// „É¨„Éº„ÇπÁµêÊûúÁôªÈå≤
// ==============================
async function finalizeRace(raceId, winner, hostId) {
  // „Åô„Åß„Å´ÁµêÊûú„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
  const exist = await pool.query(`SELECT 1 FROM rumuma_results WHERE race_id=$1 AND status='finished'`, [raceId]);
  if (exist.rowCount) return { error: "„Åì„ÅÆ„É¨„Éº„Çπ„ÅØ„Åô„Åß„Å´ÁµêÊûúÁôªÈå≤Ê∏à„Åø„Åß„Åô„ÄÇ" };

  const raceRow = await pool.query(`SELECT race_name,horses,host_id FROM rumuma_races WHERE id=$1`, [raceId]);
  if (!raceRow.rowCount) return { error: "„É¨„Éº„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì" };
  if (raceRow.rows[0].host_id !== hostId) return { error: "„Åì„ÅÆ„É¨„Éº„Çπ„ÅÆ„Éõ„Çπ„Éà„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì" };

  const bets = await pool.query(`SELECT user_id,horse,amount FROM rumuma_bets WHERE race_id=$1`, [raceId]);
  const totalPot = bets.rows.reduce((s,b) => s + Number(b.amount), 0);

  const winners = bets.rows.filter(b => b.horse === winner);
  const winSum = winners.reduce((s,b) => s + Number(b.amount), 0);

  await pool.query(`
    INSERT INTO rumuma_results(race_id,race_name,horses,winner,total_pot,status,finished_at)
    VALUES($1,$2,$3,$4,$5,'finished',now())
  `, [raceId, raceRow.rows[0].race_name, raceRow.rows[0].horses, winner, totalPot]);

  // Êâï„ÅÑÊàª„Åó‰ΩúÊàê
  if (winSum > 0) {
    for (const w of winners) {
      const share = Number(w.amount) / winSum;
      const payout = Math.floor(totalPot * share);
      await pool.query(`
        INSERT INTO pending_rewards(user_id,race_id,race_name,amount,claimed,created_at)
        VALUES($1,$2,$3,$4,false,now())
      `, [w.user_id, raceId, raceRow.rows[0].race_name, payout]);
    }
  }

  // „É¨„Éº„ÇπÊú¨‰ΩìÂâäÈô§ÔºàÂ±•Ê≠¥„ÅØ results „Å´ÊÆã„ÇãÔºâ
  await pool.query(`DELETE FROM rumuma_races WHERE id=$1`, [raceId]);

  return { ok: true, totalPot, winSum };
}

// ==============================
// „É¨„Éº„ÇπUIÁî®„ÉÜ„Ç≠„Çπ„Éà
// ==============================
function formatRaceList(rows) {
  return rows.map(r =>
    `ID:${r.id} ${r.race_name}Ôºà${(r.horses || []).join(", ")}Ôºâ ${r.finished ? "[Á∑†Âàá]" : "[ÈñãÂÇ¨‰∏≠]"}`
  ).join("\n");
}

// ==============================
// „É¨„Éº„ÇπÂ±•Ê≠¥
// ==============================
async function showRaceHistory(interaction) {
  const res = await pool.query(`
    SELECT race_id,race_name,winner,total_pot,status,finished_at
    FROM rumuma_results ORDER BY finished_at DESC LIMIT 10
  `);
  if (!res.rowCount) return ephemeralReply(interaction, { content: "Á´∂Ëµ∞Â±•Ê≠¥„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ" });

  const lines = res.rows.map(r => {
    const when = formatJST(r.finished_at);
    const tag = r.status === "canceled" ? "„Äê‰∏≠Ê≠¢„Äë" : `ÂãùËÄÖ:${r.winner}`;
    return `${when} | Race:${r.race_id} ${r.race_name} | ${tag} | Á∑èÈ°ç:${fmt(r.total_pot)}S`;
  }).join("\n");

  return ephemeralReply(interaction, { content: "üìú Áõ¥Ëøë10‰ª∂„ÅÆ„É¨„Éº„ÇπÂ±•Ê≠¥\n" + lines });
}

// ==============================
// Êâï„ÅÑÊàª„Åó‰∏ÄÊã¨Âèó„ÅëÂèñ„Çä
// ==============================
async function claimRewards(interaction) {
  const uid = interaction.user.id;
  const res = await pool.query(`
    SELECT race_id,race_name,amount
    FROM pending_rewards WHERE user_id=$1 AND claimed=false
  `,[uid]);

  if (!res.rowCount) return ephemeralReply(interaction, { content: "Êú™Âèó„ÅëÂèñ„Çä„ÅÆÊâï„ÅÑÊàª„Åó„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ" });

  let total = 0;
  const breakdown = [];
  for (const row of res.rows) {
    total += Number(row.amount);
    breakdown.push(`„ÉªRace:${row.race_id} ${row.race_name} ‚Ä¶‚Ä¶ ${fmt(row.amount)}S`);
  }

  await addCoins(uid, total, "reward_claim", `Êâï„ÅÑÊàª„Åó ${res.rowCount}‰ª∂`);
  await pool.query(`UPDATE pending_rewards SET claimed=true WHERE user_id=$1`, [uid]);

  return ephemeralReply(interaction, { content: `‚úÖ Êâï„ÅÑÊàª„Åó„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åó„ÅüÔºÅ\n${breakdown.join("\n")}\nÂêàË®à:${fmt(total)}S` });
}
/* ==============================
   „Ç¨„ÉÅ„É£ÔºàSSR„É≠„Éº„É´„ÅÇ„ÇäÔºâ
============================== */
async function playGacha(interaction) {
  const uid = interaction.user.id;
  const cost = 30;

  const balance = await getBalance(uid);
  if (balance < cost) {
    return ephemeralReply(interaction, { embeds: [createEmbed("„Ç¨„ÉÅ„É£", `ÊÆãÈ´ò‰∏çË∂≥ÔºÅÂøÖË¶Å:${fmt(cost)}S / ‰øùÊúâ:${fmt(balance)}S`, Colors.Red)] });
  }

  // „Ç≥„Çπ„ÉàÂºï„ÅçËêΩ„Å®„Åó
  await addCoins(uid, -cost, "gacha", "„Ç¨„ÉÅ„É£„ÇíÂõû„Åó„Åü");

  // ÊäΩÈÅ∏
  const roll = Math.random();
  let rarity = "S", reward = 5;
  if (roll < 0.70) { rarity = "S"; reward = 5; }
  else if (roll < 0.95) { rarity = "SR"; reward = 10; }
  else { rarity = "SSR"; reward = 50; }

  // „Ç≥„Ç§„É≥‰ªò‰∏é
  await addCoins(uid, reward, "gacha_reward", `„Ç¨„ÉÅ„É£ÂΩìÈÅ∏:${rarity}`);

  // SSR ‚Üí „É¢„Éº„ÉÄ„É´„Åß„É≠„Éº„É´‰ΩúÊàê
  if (rarity === "SSR") {
    const modal = new ModalBuilder()
      .setCustomId("gacha_ssr_modal")
      .setTitle("SSR„É≠„Éº„É´‰ΩúÊàê üéâ")
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId("role_name")
            .setLabel("„É≠„Éº„É´ÂêçÔºà20ÊñáÂ≠ó‰ª•ÂÜÖÔºâ")
            .setStyle(TextInputStyle.Short)
            .setMaxLength(20)
            .setRequired(true)
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId("role_color")
            .setLabel("„Ç´„É©„Éº„Ç≥„Éº„ÉâÔºà‰æã:#FFD700Ôºâ")
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
        )
      );
    return interaction.showModal(modal);
  }

  // S or SR „ÅÆÁµêÊûú
  return ephemeralReply(interaction, {
    embeds: [createEmbed("üé≤ „Ç¨„ÉÅ„É£ÁµêÊûú", `ÁµêÊûú: **${rarity}**\nüí∞ +${fmt(reward)}S`, rarity === "SR" ? Colors.Purple : Colors.Grey)]
  });
}

// ==============================
// SSR„É≠„Éº„É´‰ΩúÊàêÂá¶ÁêÜ
// ==============================
async function handleSSRRole(interaction) {
  const roleName = interaction.fields.getTextInputValue("role_name").trim();
  let roleColor = (interaction.fields.getTextInputValue("role_color") || "#FFD700").trim();

  if (!/^#?[0-9A-Fa-f]{6}$/.test(roleColor)) roleColor = "#FFD700";
  if (!roleColor.startsWith("#")) roleColor = "#" + roleColor;

  const guild = interaction.guild;
  if (!guild) return;

  try {
    const role = await guild.roles.create({
      name: roleName,
      color: roleColor,
      permissions: [],
      reason: `SSR„Ç¨„ÉÅ„É£ÂΩìÈÅ∏ by ${interaction.user.tag}`
    });

    // Bot„É≠„Éº„É´Áõ¥‰∏ã„Å´ÈÖçÁΩÆ
    const botHighest = guild.members.me.roles.highest;
    const newPos = Math.max(1, botHighest.position - 1);
    await role.setPosition(newPos).catch(() => {});

    // „É¶„Éº„Ç∂„Éº„Å´‰ªò‰∏é
    const member = await guild.members.fetch(interaction.user.id).catch(() => null);
    if (member) await member.roles.add(role).catch(() => {});

    // 1ÈÄ±ÈñìÂæå„Å´ÂâäÈô§
    setTimeout(async () => {
      await role.delete("SSR„É≠„Éº„É´ÊúâÂäπÊúüÈôêÂàá„Çå").catch(() => {});
    }, 7 * 24 * 60 * 60 * 1000);

    return ephemeralReply(interaction, {
      embeds: [createEmbed("SSRÂΩìÈÅ∏ üéâ", `„É≠„Éº„É´ **${roleName}** „Çí‰ΩúÊàê„Åó‰ªò‰∏é„Åó„Åæ„Åó„ÅüÔºÅÔºàËâ≤:${roleColor}Ôºâ\n„Åì„ÅÆ„É≠„Éº„É´„ÅØ **Bot„É≠„Éº„É´Áõ¥‰∏ã** „Å´ÈÖçÁΩÆ„Åï„Çå„ÄÅ1ÈÄ±ÈñìÂæå„Å´Ëá™ÂãïÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`, Colors.Gold)]
    }, 30000);
  } catch (e) {
    console.error("SSR„É≠„Éº„É´‰ΩúÊàêÂ§±Êïó:", e);
    return ephemeralReply(interaction, {
      embeds: [createEmbed("SSR„É≠„Éº„É´", "„É≠„Éº„É´‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇBot„É≠„Éº„É´„ÅÆ‰ΩçÁΩÆ„Å®Ê®©Èôê„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", Colors.Red)]
    }, 30000);
  }
}
/* ==============================
   „Ç∏„É£„Ç∞„É©„ÉºÔºöÁ¢∫ÁéáË®≠ÂÆö
============================== */
const DEFAULT_PROBS = {
  big: 1/180,   // BIG BONUS
  reg: 1/90,    // REG BONUS
  grape: 1/6,   // „Å∂„Å©„ÅÜ
  cherry: 1/12, // „ÉÅ„Çß„É™„Éº
};

// Ë®≠ÂÆöÂèñÂæó
async function getSlotConfig() {
  const rs = await pool.query(`SELECT * FROM slot_config ORDER BY id DESC LIMIT 1`);
  if (!rs.rowCount) return DEFAULT_PROBS;
  return {
    big: Number(rs.rows[0].big),
    reg: Number(rs.rows[0].reg),
    grape: Number(rs.rows[0].grape),
    cherry: Number(rs.rows[0].cherry),
  };
}

// Ë®≠ÂÆö‰øùÂ≠ò
async function setSlotConfig(big, reg, grape, cherry) {
  await pool.query(`INSERT INTO slot_config(big,reg,grape,cherry,updated_at) VALUES($1,$2,$3,$4,now())`, [big, reg, grape, cherry]);
}

/* ==============================
   „Ç∏„É£„Ç∞„É©„ÉºÔºö„É™„Éº„É´Âà∂Âæ°
============================== */
const JUGGLER_BET = 10;

function drawSymbol(cfg) {
  const r = Math.random();
  if (r < cfg.big) return "7Ô∏è‚É£";
  if (r < cfg.big + cfg.reg) return "üé∞";
  if (r < cfg.big + cfg.reg + cfg.cherry) return "üçí";
  if (r < cfg.big + cfg.reg + cfg.cherry + cfg.grape) return "üçá";
  return ["üçã","‚≠ê"][Math.floor(Math.random()*2)];
}

function spinBoard(cfg) {
  return [
    [drawSymbol(cfg), drawSymbol(cfg), drawSymbol(cfg)],
    [drawSymbol(cfg), drawSymbol(cfg), drawSymbol(cfg)],
    [drawSymbol(cfg), drawSymbol(cfg), drawSymbol(cfg)]
  ];
}

function renderBoard(board) {
  return (
    `| ${board[0][0]} | ${board[1][0]} | ${board[2][0]} |\n` +
    `| ${board[0][1]} | ${board[1][1]} | ${board[2][1]} |\n` +
    `| ${board[0][2]} | ${board[1][2]} | ${board[2][2]} |`
  );
}

function judge(board) {
  const line = [board[0][1], board[1][1], board[2][1]];
  const all = (s) => line.every(v => v === s);
  if (all("7Ô∏è‚É£"))  return { reward: 300, type: "BIG" };
  if (all("üé∞"))  return { reward: 100, type: "REG" };
  if (all("üçá"))  return { reward: 15,  type: "„Å∂„Å©„ÅÜ" };
  if (all("üçí"))  return { reward: 10,  type: "„ÉÅ„Çß„É™„Éº" };
  return { reward: 0, type: "„Éè„Ç∫„É¨" };
}

/* ==============================
   „Ç∏„É£„Ç∞„É©„ÉºÔºö„Éó„É¨„Ç§
============================== */
async function playCasinoSlot(interaction) {
  const uid = interaction.user.id;
  const balance = await getBalance(uid);

  if (balance < JUGGLER_BET) {
    return ephemeralReply(interaction, { embeds: [createEmbed("üé∞ „Ç∏„É£„Ç∞„É©„Éº", `ÊÆãÈ´ò‰∏çË∂≥ÔºÅÂøÖË¶Å:${fmt(JUGGLER_BET)}S / ‰øùÊúâ:${fmt(balance)}S`, Colors.Red)] });
  }

  const cfg = await getSlotConfig();
  const finalBoard = spinBoard(cfg);
  const { reward, type } = judge(finalBoard);
  const net = reward - JUGGLER_BET;

  await addCoins(uid, net, "casino_slot", `ÂΩπ:${type}`);

  // „É°„Ç§„É≥UI
  await interaction.deferReply({ ephemeral: true });

  let embed = new EmbedBuilder()
    .setTitle("üé∞ „Ç∏„É£„Ç∞„É©„Éº START!!")
    .setDescription("```\n| ‚ùì | ‚ùì | ‚ùì |\n| ‚ùì | ‚ùì | ‚ùì |\n| ‚ùì | ‚ùì | ‚ùì |\n```")
    .setColor(Colors.Blurple);
  await interaction.editReply({ embeds: [embed] });

  // „Éâ„É©„É†È†ÜÁï™ÂÅúÊ≠¢ÊºîÂá∫
  for (let i=0; i<3; i++) {
    await new Promise(r => setTimeout(r, 1200));
    const tempBoard = spinBoard(cfg);
    for (let j=0;j<=i;j++) tempBoard[j] = finalBoard[j];
    embed = new EmbedBuilder()
      .setTitle("üé∞ ÂõûËª¢‰∏≠‚Ä¶")
      .setDescription("```\n" + renderBoard(tempBoard) + "\n```")
      .setColor(Colors.Blue);
    await interaction.editReply({ embeds: [embed] });
  }

  // ÊúÄÁµÇÁµêÊûú
  const newBalance = await getBalance(uid);
  let resultEmbed = new EmbedBuilder()
    .setTitle(`üé≤ ÁµêÊûú: ${type}`)
    .setDescription("```\n" + renderBoard(finalBoard) + "\n```" + `\nüí∞ Áç≤Âæó: ${fmt(reward)}S\nüìâ ÂèéÊîØ: ${fmt(net)}S\nüíµ ÊÆãÈ´ò: ${fmt(newBalance)}S`)
    .setColor(type==="BIG" ? Colors.Gold : type==="REG" ? Colors.Red : type==="„Éè„Ç∫„É¨" ? Colors.Grey : Colors.Green);

  await interaction.editReply({ embeds: [resultEmbed] });

  // ÊºîÂá∫„Åî„Å®„ÅÆËøΩÂä†
  if (type === "BIG") {
    await interaction.followUp({ embeds: [createEmbed("üéÜ BIG BONUS üéÜ", "üåà Á•ùÁ¶è„É¢„Éº„ÉâÁ™ÅÂÖ•ÔºÅ\n„Éï„Ç°„É≥„Éï„Ç°„Éº„É¨„ÅåÈ≥¥„ÇäÈüø„ÅèÔºÅ", Colors.Gold)], ephemeral: true });
  } else if (type === "REG") {
    await interaction.followUp({ embeds: [createEmbed("üî¥ REG BONUS!", "‚ô™ „Éî„Éù„Éî„Éù„Éº„É≥ÔºÅ", Colors.Red)], ephemeral: true });
  } else if (type === "„Å∂„Å©„ÅÜ" || type === "„ÉÅ„Çß„É™„Éº") {
    await interaction.followUp({ embeds: [createEmbed(`üçí ${type} ÊèÉ„ÅÑÔºÅ`, "„Ç≠„É©„Ç≠„É©„É™„É≥‚ú®", Colors.Green)], ephemeral: true });
  } else {
    await interaction.followUp({ embeds: [createEmbed("‚ùå „Éè„Ç∫„É¨", "‚ô™ „Ç∑„Éº„É≥‚Ä¶", Colors.Grey)], ephemeral: true });
  }
}

/* ==============================
   ÁÆ°ÁêÜUIÔºö„Ç∏„É£„Ç∞„É©„ÉºÁ¢∫ÁéáË®≠ÂÆö
============================== */
async function openSlotConfigModal(interaction) {
  if (!interaction.member?.permissions?.has(PermissionsBitField.Flags.Administrator)) {
    return ephemeralReply(interaction, { content: "ÁÆ°ÁêÜËÄÖÊ®©Èôê„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ" });
  }
  const modal = new ModalBuilder()
    .setCustomId("slot_config_modal")
    .setTitle("üé∞ „Ç∏„É£„Ç∞„É©„ÉºÁ¢∫ÁéáË®≠ÂÆö")
    .addComponents(
      new ActionRowBuilder().addComponents(
        new TextInputBuilder().setCustomId("big").setLabel("BIGÁ¢∫Áéá (‰æã: 0.005)").setStyle(TextInputStyle.Short).setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder().setCustomId("reg").setLabel("REGÁ¢∫Áéá (‰æã: 0.01)").setStyle(TextInputStyle.Short).setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder().setCustomId("grape").setLabel("„Å∂„Å©„ÅÜÁ¢∫Áéá").setStyle(TextInputStyle.Short).setRequired(true)
      ),
      new ActionRowBuilder().addComponents(
        new TextInputBuilder().setCustomId("cherry").setLabel("„ÉÅ„Çß„É™„ÉºÁ¢∫Áéá").setStyle(TextInputStyle.Short).setRequired(true)
      )
    );
  return interaction.showModal(modal);
}

async function handleSlotConfigModal(interaction) {
  const big = parseFloat(interaction.fields.getTextInputValue("big"));
  const reg = parseFloat(interaction.fields.getTextInputValue("reg"));
  const grape = parseFloat(interaction.fields.getTextInputValue("grape"));
  const cherry = parseFloat(interaction.fields.getTextInputValue("cherry"));

  if (![big, reg, grape, cherry].every(v => !isNaN(v) && v > 0)) {
    return ephemeralReply(interaction, { content: "ÂÖ•Âäõ„Åå‰∏çÊ≠£„Åß„Åô„ÄÇÊï∞ÂÄ§„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" });
  }

  await setSlotConfig(big, reg, grape, cherry);
  return ephemeralReply(interaction, { content: "‚úÖ „Ç∏„É£„Ç∞„É©„ÉºÁ¢∫Áéá„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ" });
}
/* ==============================
   Interaction Handler
============================== */
client.on("interactionCreate", async (interaction) => {
  try {
    // ===== „Éú„Çø„É≥ =====
    if (interaction.isButton()) {
      switch (interaction.customId) {
        /* --- ÁÆ°ÁêÜ --- */
        case "admin_adjust":
          if (!interaction.member?.permissions?.has(PermissionsBitField.Flags.Administrator))
            return ephemeralReply(interaction, { content: "ÁÆ°ÁêÜËÄÖÊ®©Èôê„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ" });
          const modal = new ModalBuilder()
            .setCustomId("admin_adjust_modal")
            .setTitle("„É¶„Éº„Ç∂„Éº„Ç≥„Ç§„É≥Ë™øÊï¥")
            .addComponents(
              new ActionRowBuilder().addComponents(
                new TextInputBuilder().setCustomId("target_user").setLabel("ÂØæË±°„É¶„Éº„Ç∂„ÉºID").setStyle(TextInputStyle.Short).setRequired(true)
              ),
              new ActionRowBuilder().addComponents(
                new TextInputBuilder().setCustomId("amount").setLabel("Â¢óÊ∏õÈ°ç (‰æã: 100 or -50)").setStyle(TextInputStyle.Short).setRequired(true)
              )
            );
          return interaction.showModal(modal);

        case "view_history_admin": {
          const res = await pool.query(`SELECT * FROM history ORDER BY created_at DESC LIMIT 15`);
          if (!res.rowCount) return ephemeralReply(interaction, { content: "Â±•Ê≠¥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ" });
          await replyHistoryEmbeds(interaction, res.rows);
          return;
        }

        case "slot_config": return openSlotConfigModal(interaction);

        /* --- „Ç≥„Ç§„É≥ --- */
        case "daily_claim": return claimDaily(interaction);
        case "check_balance": {
          const bal = await getBalance(interaction.user.id);
          return ephemeralReply(interaction, { embeds: [createEmbed("ÊÆãÈ´òÁ¢∫Ë™ç", `${fmt(bal)} S`)] });
        }
        case "view_history_user": {
          const uid = interaction.user.id;
          const res = await pool.query(`SELECT * FROM history WHERE user_id=$1 ORDER BY created_at DESC LIMIT 15`, [uid]);
          if (!res.rowCount) return ephemeralReply(interaction, { content: "Â±•Ê≠¥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ" });
          await replyHistoryEmbeds(interaction, res.rows);
          return;
        }
        case "view_ranking": return showRanking(interaction);

        /* --- „Ç¨„ÉÅ„É£ --- */
        case "gacha_play": return playGacha(interaction);

        /* --- „Ç∏„É£„Ç∞„É©„Éº --- */
        case "casino_slot": return playCasinoSlot(interaction);

        /* --- „É¨„Éº„Çπ --- */
        case "rumuma_history": return showRaceHistory(interaction);
        case "rumuma_claim_rewards": return claimRewards(interaction);
        // Ôºà‰ªñ„ÅÆ„É¨„Éº„ÇπÊìç‰Ωú„ÅØ Part3 „ÅßÂá¶ÁêÜÊ∏à„ÅøÔºâ
      }
    }

    // ===== „É¢„Éº„ÉÄ„É´ =====
    if (interaction.type === InteractionType.ModalSubmit) {
      if (interaction.customId === "admin_adjust_modal") {
        const uid = interaction.fields.getTextInputValue("target_user").trim();
        const amount = parseInt(interaction.fields.getTextInputValue("amount"), 10);
        if (isNaN(amount)) return ephemeralReply(interaction, { content: "ÈáëÈ°ç„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ" });
        await addCoins(uid, amount, "admin_adjust", "ÁÆ°ÁêÜËÄÖÊìç‰Ωú");
        return ephemeralReply(interaction, { content: `‚úÖ „É¶„Éº„Ç∂„Éº:${uid} „Å´ ${fmt(amount)}S Ë™øÊï¥„Åó„Åæ„Åó„Åü„ÄÇ` });
      }

      if (interaction.customId === "gacha_ssr_modal") return handleSSRRole(interaction);

      if (interaction.customId === "slot_config_modal") return handleSlotConfigModal(interaction);
    }

    // ===== „Çª„É¨„ÇØ„Éà„É°„Éã„É•„Éº =====
    if (interaction.isStringSelectMenu()) {
      // Part3 „É¨„Éº„ÇπÁî®„ÅÆÂá¶ÁêÜ„Åå„Åì„Åì„Å´Áµ±Âêà„Åï„Çå„ÇãÔºàÁúÅÁï•„Åõ„ÅöÔºâ
    }
  } catch (e) {
    console.error("interaction error:", e);
    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ content: "‚ö†Ô∏è „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral: true });
    }
  }
});

/* ==============================
   „É°„ÉÉ„Çª„Éº„Ç∏Áõ£Ë¶ñÔºöÁô∫Ë®ÄÂ†±ÈÖ¨
============================== */
client.on(Events.MessageCreate, async (msg) => {
  try {
    if (msg.author.bot || !msg.guild) return;
    if (msg.content.trim().length < 2) return;
    await handleMessageReward(msg);
  } catch (e) {
    console.error("message reward error:", e);
  }
});

/* ==============================
   „Éá„Ç§„É™„ÉºÂèóÂèñ„É™„Çª„ÉÉ„ÉàÔºàJST 05:00Ôºâ
============================== */
schedule.scheduleJob("0 20 * * *", async () => { // UTC20 = JST05
  await pool.query("DELETE FROM daily_claims");
  console.log("‚úÖ „Éá„Ç§„É™„ÉºÂèóÂèñ„É™„Çª„ÉÉ„ÉàÂÆå‰∫Ü (JST05:00)");
});

/* ==============================
   Ready
============================== */
client.once("ready", async () => {
  console.log(`‚úÖ Logged in as ${client.user.tag}`);
  await ensureTables();

  // ÁÆ°ÁêÜUI
  if (process.env.ADMIN_CHANNEL_ID) {
    const ch = await client.channels.fetch(process.env.ADMIN_CHANNEL_ID).catch(() => null);
    if (ch) {
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId("admin_adjust").setLabel("‚öôÔ∏è „Ç≥„Ç§„É≥Â¢óÊ∏õ").setStyle(ButtonStyle.Danger),
        new ButtonBuilder().setCustomId("slot_config").setLabel("üé∞ „Ç∏„É£„Ç∞„É©„ÉºÁ¢∫ÁéáË®≠ÂÆö").setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId("view_history_admin").setLabel("üìú ÂÖ®Â±•Ê≠¥").setStyle(ButtonStyle.Secondary)
      );
      await ch.send({ content: "ÁÆ°ÁêÜ„É°„Éã„É•„Éº", components: [row] });
    }
  }

  // „Éá„Ç§„É™„Éº/„Ç≥„Ç§„É≥UI
  if (process.env.DAILY_CHANNEL_ID) {
    const ch = await client.channels.fetch(process.env.DAILY_CHANNEL_ID).catch(() => null);
    if (ch) {
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId("daily_claim").setLabel("üéÅ „Éá„Ç§„É™„Éº„Ç≥„Ç§„É≥").setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId("gacha_play").setLabel("üé≤ „Ç¨„ÉÅ„É£").setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId("casino_slot").setLabel("üé∞ „Ç∏„É£„Ç∞„É©„Éº").setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId("check_balance").setLabel("üí∞ ÊÆãÈ´òÁ¢∫Ë™ç").setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId("view_history_user").setLabel("üìú ÂèñÂºïÂ±•Ê≠¥").setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId("view_ranking").setLabel("üèÖ „É©„É≥„Ç≠„É≥„Ç∞").setStyle(ButtonStyle.Primary)
      );
      await ch.send({ content: "„Ç≥„Ç§„É≥„É°„Éã„É•„Éº", components: [row] });
    }
  }

  // „É¨„Éº„ÇπUI
  if (process.env.RUMUMA_CHANNELS) {
    for (const cid of process.env.RUMUMA_CHANNELS.split(",")) {
      const ch = await client.channels.fetch(cid.trim()).catch(() => null);
      if (ch) {
        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder().setCustomId("rumuma_history").setLabel("üóÇ „É¨„Éº„ÇπÂ±•Ê≠¥").setStyle(ButtonStyle.Secondary),
          new ButtonBuilder().setCustomId("rumuma_claim_rewards").setLabel("üí≥ Êâï„ÅÑÊàª„Åó").setStyle(ButtonStyle.Primary)
        );
        await ch.send({ content: "„É¨„Éº„Çπ„É°„Éã„É•„Éº", components: [row] });
      }
    }
  }
});

/* ==============================
   HTTP Server (Render)
============================== */
const PORT = process.env.PORT || 10000;
http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Bot is running!\n");
}).listen(PORT, () => {
  console.log(`üåê HTTP server running on port ${PORT}`);
});

/* ==============================
   Login
============================== */
client.login(process.env.DISCORD_TOKEN);
